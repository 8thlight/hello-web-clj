;; gorilla-repl.fileformat = 1

;; **
;;; # Databases
;;; 
;;; Clojure Databases can take advantage of JDBC - just like you might expect.
;;; 
;; **

;; @@
(require '[clojure.java.jdbc :as j])
;; @@

;; **
;;; Note - this requires the following Lein deps
;;; 
;;; ```clojure
;;; [org.clojure/java.jdbc "0.4.2"]
;;; [org.xerial/sqlite-jdbc "3.8.11.2"]
;;;  ```
;;;  
;;;  To connect to SQL Lite you create a simple defspec
;; **

;; @@
(def db-spec {:classname "org.sqlite.JDBC"
                                 :subprotocol "sqlite"
                                 :subname "data/db"})
;; @@

;; **
;;; And to do commands you can call simple wrappers on the JDBC Library
;; **

;; @@
(j/db-do-commands db-spec (j/drop-table-ddl :fruit))
(j/db-do-commands db-spec (j/create-table-ddl :fruit [:name "VARCHAR(32)"] [:appearance "VARCHAR(32)"]))
;; @@

;; @@
(j/insert! db-spec :fruit
  #_=> {:name "Apple" :appearance "rosy"})
;; @@

;; @@
(j/query db-spec ["select * from fruit where appearance = ?" "rosy"])
;; @@

;; **
;;; This is effective, but hardly pretty and Clojure friendly.
;;; 
;;; The current most popluar way of interacting with databases is YeSQL.
;; **

;; @@
(require '[yesql.core :as y])
;; @@

;; **
;;; Now YESQL is not an ORM.  It has:
;;; 
;;; ```sql
;;; -- name: all-fruit
;;; SELECT *
;;; FROM fruit
;;; 
;;; -- name: fruit-by-appearance
;;; SELECT *
;;; FROM fruit
;;; WHERE appearance = :appearance
;;; 
;;; -- name: clear-fruit!
;;; DELETE FROM fruit
;;; 
;;; -- name: create-fruit<!
;;; INSERT INTO fruit (name, appearance) VALUES(:name, :appearance)
;;; ```
;; **

;; @@
(y/defqueries "queryfile.sql" {:connection db-spec})
;; @@

;; @@
(all-fruit)
;; @@

;; @@
(fruit-by-appearance {:appearance "rosy"})
;; @@

;; @@
(clear-fruit!)
;; @@

;; **
;;; Queries that don't return results need a bang (aka side effects)
;; **

;; @@
(clojure.repl/doc clear-fruit!)
;; @@

;; **
;;; Autogenerated ids require funky syntax
;; **

;; @@
(create-fruit<! {:appearance "orange" :name "orange"})
;; @@

;; @@
(all-fruit)
;; @@

;; **
;;; Migrating a DB - using the tool Ragtime
;; **

;; @@
(require '[ragtime.repl :as repl])
(require '[ragtime.jdbc :as jdbc])

;; @@

;; @@
(def config {:datastore (jdbc/sql-database {:connection-uri "jdbc:sqlite::data:db"}) :migrations (jdbc/load-resources "migrations")})
;; @@

;; @@
(repl/migrate config)
;; @@

;; @@
(repl/rollback config)
;; @@

;; @@

;; @@
